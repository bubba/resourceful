% -*- fill-column: 80; TeX-command-extra-options: "-shell-escape" -*-
\documentclass{report}
\usepackage{minted}
\usepackage{syntax}
\usepackage{mathpartir}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{graphs,graphdrawing,decorations.pathreplacing,decorations.pathmorphing,arrows.meta}
\usegdlibrary{layered,trees}
\usepackage{multicol}

\usepackage{fontspec}
\setmonofont{Menlo}[Scale=0.8]

\usepackage{newunicodechar}
\newfontface\mathsymbolfont{STIXGeneral}
\newunicodechar{⟦}{{\mathsymbolfont{\llbracket}}}
\newunicodechar{⟧}{{\mathsymbolfont{\rrbracket}}}
\newunicodechar{⊢}{{\mathsymbolfont{\vdash}}}
\newunicodechar{⦂}{{\mathsymbolfont{⦂}}}
\newunicodechar{⋎}{{\mathsymbolfont{\curlyvee}}}
\newunicodechar{∷}{{\mathsymbolfont{∷}}}

\begin{document}

\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}
\newcommand{\IO}{\mathsf{IO}}
\newcommand{\bind}{>\!\!>\!\!=} \newcommand{\concbind}{>\!\!>\!>\!\!=}
\newcommand{\subtyp}{\geq:}
\newcommand{\notsubtyp}{\ngeq:}
\newcommand{\lift}[1]{\ensuremath{\llbracket#1\rrbracket}}
\newcommand{\use}[2]{\ensuremath{\llbracket#2\rrbracket_{#1}}}

\author{Luke Lau}
\title{A Resourceful Monad for IO}
\begin{titlepage}
  \maketitle
\end{titlepage}

\chapter{Introduction}
The immutability and pureness of certain functional languages make them seem
like a perfect fit for parallelism and concurrency. The lack of side effects
mean we are free to compute in any whatever order we please, without any shared
mutable state, free from the fear of race conditions and deadlocks. However, in
the real world, code is never completely pure. Useful programs need to interact
with the real world at some point, whether that be by reading from standard
input or connecting to a network. 

Effectfullness and order

The most popular solution today is to capture the entire state of the outside
universe and write functions that operate on state. That way any particle that
may have been perturbed by writing to \texttt{stdout} is appropriately reflected.

Concurrent Clean models this by threading the \texttt{World} in and out of
functions. Uniqueness types guarantee that the same world is only used once, so
that the programmer does create an alternative timeline by duplicating it.

\begin{minted}[breaklines]{clean}
readFile :: !String !*World -> (!MaybeError FileError String,!*World)
\end{minted}

Haskell also treats the world as a state, but without the uniquness guarantee.
Any function that interacts with the World returns a function, which returns a
new version of the World alongside the function result.\footnote{The actual
  definition in GHC is \\ \mintinline{haskell}{newtype IO a = IO (State#
    RealWorld -> (# State# RealWorld, a #))}}

\mint{haskell}|type IO a = World -> (World, a)|

How Haskell ensures that an old World isn't erroneously used instead of the
fresh new one, is by hiding the implementation from the user, tucking it away
into a \textit{monad}. This notion of using monads to sequence together stateful
computations was first introduced by Peyton Jones and
Wadler~\cite{peytonjones1993}\cite{wadler1995}. The programmer no longer needs
to keep track of the world, and they can keep their imperative code imperative,
and their pure code pure. This marriage of monads and IO is one of the crown
jewels of functional language research to come out of Haskell.
\begin{minted}{haskell}
class Monad IO where
  return x = \w -> (w, x)
  x >>= f = \w -> let (w', y) = x w in f y w'
\end{minted}

Now IO actions can be easily chained together in a type-safe way that ensures
their ordering.

This ordering however, imposes limitations. One of the main benefits of pure
functional languages, is that since expressions do not have side effects, there
is no restriction on what order they need to be evaluated in.

Take for example the following snippet.
\begin{minted}{haskell}
f, g, h :: Int -> Int
f x = g x + h x
\end{minted}

\texttt{g} could be evaluted before \texttt{h}, or \texttt{h} could
be evaluted before \texttt{g}. It wouldn't make a difference because there
are no side effects. One might be tempted then to evaluate the two expressions
concurrently -- and that would be safe.

The same cannot be said for impure IO actions -- and the type system prevents that.
\begin{minted}{haskell}
f, g, h :: Int -> IO Int
f x = g x >>= \y -> y + h x
\end{minted}
We need to explicitly bind the actions and sequence evaluation.
Does this mean that concurrency is not possible for IO actions? No, as many
languages provide primitives to run these actions concurrently in a type safe
way. Haskell has \mintinline{haskell}{forkIO}, but for simpliclty we are going
to assume a higher level function for running two IO actions simultaneously and
collecting the results.

\begin{minted}{haskell}
concurrently :: IO a -> IO b -> IO (a, b)
\end{minted}

Now we can use it to run our two IO actions side by side safely. 
\begin{minted}{haskell}
f, g, h :: Int -> IO Int
f x = g x `concurrently` h x >>= \(a, b) -> return (a + b)
\end{minted}

But what if \texttt{g} and \texttt{h} actually looked like this?

\begin{minted}{haskell}
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()

g x = do
  txt <- readFile "foo.txt"
  return (x + (read txt))
h x = do
  writeFile "foo.txt" "hello"
  return (42 - x)
\end{minted}

Running these two functions concurrently could be disastrous as the order in
which they execute could affect the outcome of the program, and all of a sudden
some innocuous looking IO functions end up introducing non-determinism and
tricky race conditions into our program.

We know statically, that a program such as \mint{haskell}|g x `concurrently` h
x| should probably not be allowed. But then why did the type system allow it?
Has it failed us? The goal of the type system is to disallow as many incorrect
programs as possible while allowing as many correct programs as possible. It is
a fine line as to what programs are defined correct and what are defined as
incorrect --- a type system too lenient and buggy programs will creep through. A
type system too strict and the programmer will end up wasting time fighting the
type checker.

In this piece of research however, we are going to investigate the point in the
design space that rejects such programs. We do \textbf{not} want to allow
programs that have glaring race conditions, where we can see that there is a
contentious access of resources.

The genesis of the rest of this work is based around the idea of modelling the
resources in use at the type level. We begin by adding another type parameter to
our IO type to represent what resource an IO action uses:

\mint{haskell}|type IO r a = World -> (World, a)|

This is a phantom type parameter, as it only exists at the type level. Now our
type signatures could look like this, annotating the API with what resources it
might use.

\begin{minted}{haskell}
data Resource = FileSystem | Net | Database | OpenGL | ...
readFile :: FilePath -> IO FileSystem ()
writeFile :: FilePath -> IO FileSystem String
readSocket :: Socket -> IO Net ()
runQuery :: Query a -> IO Database a
swapBuffers :: IO OpenGL ()
\end{minted}

Keep in mind we are painting in broad strokes when we use the word
``resource''. In the running example the resource is a file,
\texttt{foo.txt}. But the notion of a resource can be as broad or as specific as
the author of a function needs it to be. It could represent a specific database
instance, or a single network socket. For simplicity in our example we will
consider the entire file system as a single resource, the entire network as
a single resource, and so on.

Now that we know what resources each $\IO$ action is using, we would like to
change the type of our concurrent function to take advantage of this new
information. Perhaps we would like to reject any two functions that use the same
resource, i.e. it only accepts $\IO$ actions with distinct resources.

\mint{haskell}|concurrently :: r /~ s => IO r a -> IO s b -> IO ? (a, b)|

You can read \verb$r \~ s$ as ``r is distinct from s'', or the opposite of a
\verb$r \~ s$ equality constraint that one might see in a type signature. This
of course however, does not exist in Haskell.  And what does it exactly mean for
two resources to ``be distinct''? And what resources would the returned $\IO$
use?

These are questions that are answered in Chapter~\ref{chapter:system} with a
formal definition of a type system that tracks resource usage. We explore a
specific point in the design space, where the type system rejects programs like
\[
\textsf{readFile} \curlyvee \textsf{readFile}
\]
But accepts and assigns types to programs such as
\[
\textsf{readFile} \curlyvee \textsf{readNet} : \IO_{\textsf{File} \cup \textsf{Net}} \ () \times ()
\]
In short, we aim to create a type system that keeps tracks of the resources
being used, so that the programmer doesn't have to. It \textbf{does not} aim to
solve concurrency --- there will still be programs that have concurrency errors
that the type system will still allow. We just aim to narrow down the scope of
valid programs, by ruling out those with blatant, concurrent resource access
errors. 

\section{Overview}

In Chapter~\ref{chapter:background} we will talk about the inspirations of the
type system, namely separation logic, and how it parallels with our monadic
language. We will also briefly go over what we mean by a monad formally, and
then look at the original design of Hindley-Damas-Milner which we will build upon.

Chapter~\ref{chapter:system} introduces the language, its type system and its
semantics.  It gives a complete definition of all the parts needed to prove
properties.  We prove these properties in Chapter~\ref{cha:properties}, in
which we eventually build up and present a proof of its soundness. This proof,
and the others that accompany it, are then mechanised within the dependently
typed language and proof assistant Agda. The technique and design used to do so
are discussed in Chapter~\ref{cha:mechanisation}.

Finally, Chapter~\ref{cha:evaluation} evaluates our type system, how it might be
refined, and areas of further work that would be interesting to explore.

\include{background}

\include{system}

\include{properties}

\include{mechanisation}

\include{evaluation}

\include{appendix}

\bibliographystyle{plain}
\bibliography{report}

\end{document}

% LocalWords: stdout LocalWords Idris haskell
%%% Local Variables:
%%% TeX-engine: luatex
%%% End: