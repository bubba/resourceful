\chapter{Evaluation and Further Work}\label{cha:evaluation}
\section{Heap well formedness}
In the system defined in the previous chapter we have proved it is
sound, and moreover we can show that every concurrent expression has a
well typed heap --- that is a resource is not used more than once in the
heap, and thus resources are not accessed concurrently.

\begin{theorem}[Concurrent heap is well formed]\label{theorem:conc}
  If $\Gamma \vdash e_1 \curlyvee e_2 : IO_\rho \tau$, then $\textsf{ok} \ \rho$
\end{theorem}
\begin{proof}
  By induction on the possible proofs for $\Gamma \vdash e_1 \curlyvee e_2 : IO_\rho \tau$.
  \begin{description}
  \item[\textmd{\boxed{\textsc{Conc}}}]
    We need to show $\textsf{ok} \ \rho_1 \cup \rho_2$, and from the premises we have $\textsf{ok} \ \rho_1 \cup \rho_2$.
  \item[\textmd{\boxed{\textsc{Sub}}}]
    We need to show $\textsf{ok} \ \rho'$ and from the premises, we also have $\textsf{ok} \ \rho'$. 
  \end{description}
\end{proof}
As you can see, this is straightforward to prove. Perhaps it is too
straightforward. What we would really like to prove is for all terms
$e$:
\newtheorem{conjecture}{Conjecture}
\begin{conjecture}\label{conjecture:strongconc}
  If $\centerdot \vdash e : \IO_\rho \tau$, then $\textsf{ok} \ \rho$
\end{conjecture}
This is a stronger version of Theorem~\ref{theorem:conc}. However this
is not made easy in the system as it stands, for one simple yet
annoying reason: Types are not necessarily well formed, and
\textsc{Abs} allows any type to be introduced. This can be easily
shown with the identity function.

\[
  \inferrule*[Right=Abs]{
  \inferrule*[Right=Var]{x : \IO_{\textsf{File} \cup \textsf{File}} \tau  \in
    \centerdot , x : \IO_{\textsf{File} \cup \textsf{File}} \tau \\  \IO_{\textsf{File} \cup \textsf{File}} \tau >
    \IO_{\textsf{File} \cup \textsf{File}} \tau }{\centerdot , x : \IO_{\textsf{File} \cup
      \textsf{File}} \tau \vdash x : \IO_{\textsf{File} \cup \textsf{File}} \tau}
}
{\centerdot \vdash \lambda x . x : \IO_{\textsf{File} \cup \textsf{File}} \tau \rightarrow \IO_{\textsf{File} \cup \textsf{File}} \tau}
\]

It acts as a mechanism to generate types with malformed heaps, such as
an $\IO$ monad that contains two \textsf{File}s in its heap.  In
reality this is not an issue, as there is no way to construct a value
to pass into this lambda. Because of this I believe that Conjecture~\ref{conjecture:strongconc} is still
provable, but only when the context only contains well formed type
schemes, and hence why it only applies for the empty context.

We can extend this to include a relation for well-formed contexts and
well-formed types, and use this in our definition. 

\begin{mathpar}
  \boxed{\textsf{ok} \ \Gamma} \\
  \infer{ }{\textsf{ok} \ \centerdot} \and \infer{\textsf{ok} \ \Gamma \\ \textsf{ok}
    \ \sigma}{\textsf{ok} \ \Gamma , x : \sigma } \\
  \boxed{\textsf{ok} \ \sigma} \\
  \infer{\textsf{ok} \ \tau}{\textsf{ok} \ \forall \alpha_1 , \ldots , \alpha_n \cdot \tau} \\
  \boxed{\textsf{ok} \ \tau} \\
  \infer{ }{\textsf{ok} \ \square} \and
  \infer{ }{\textsf{ok} \ \alpha} \and
  \infer{\textsf{ok} \ \tau \\ \textsf{ok} \ \tau'}{\textsf{ok} \ \tau \rightarrow \tau'}
  \and
  \infer{\textsf{ok} \ \tau \\ \textsf{ok} \ \tau'}{\textsf{ok} \ \tau \times \tau'}
  \and
  \infer{\textsf{ok} \ \tau \\ \textsf{ok} \ \rho}{\textsf{ok} \ \IO_\rho \tau}
\end{mathpar}

\begin{conjecture}
  If $\textsf{ok} \ \Gamma$ and $\Gamma \vdash e : \IO_\rho \tau$, then $\textsf{ok} \ \rho$
\end{conjecture}
So far two lemmas have been proven to aid in the proof of the above
conjecture.
\begin{lemma}
  If $\textsf{ok} \ \tau$ then for any substitution $s$, $\textsf{ok} \ \tau[s]$
\end{lemma}
\begin{lemma}
  If $\textsf{ok} \ \sigma$ and $\sigma > \tau$, then $\textsf{ok} \ \tau$
\end{lemma}

This introduces a notion of ``well-typed types'' and adds quite a bit
of extra overhead to the system, so it is left as further work.

\section{Let-polymorphism}
All this theory was motivated by a very practical cause: to provide
some simple concurrency guarantees at the type level in a programming
language. Thus the intention is that some of this may eventually make
its way into a type system of an existing or novel language.

So instead of starting with the simply typed lambda calculus, the
system was based off of the Hindley-Damas-Milner system with its
polymorphic type discipline. It cannot be understated the amount of
extra complexity and work this introduced into the proofs for
soundness, but polymorphism is a near-essential feature in today's
modern functional programming languages. The let polymorphism does not
interact much with the monadic and resourceful parts of the type
system, but it is desirable to show that the two are compatible with
each other regardless.

\section{Almost syntax directed}
As mentioned earlier, the system was based off a syntax directed
treatment of Hindley-Damas-Milner. That meant that there were only
four rules instead of the usual six, where instantiation and
generalisation are rolled into \textsc{Var} and \textsc{Let}
respectively. The main benefit of this was that it meant there was
exactly one typing judgement for each form of syntax, so constructing
proofs for a program was a breeze --- you just follow the corresponding rules
for each term. For example, in the expression $\letin{z = \lambda x . x}{z \
  z}$, a let consisting of an abstraction and an application, the proof begins with a
\textsc{Let}, then the premises \textsc{Abs} and \textsc{App} as shown
in figure~\ref{fig:syntaxdirected}.


\begin{figure}
  \centering
  \begin{mathpar}
    \infer*[Right=Let]{
      \infer*[Right=Abs]{
        \infer*[Right=Var]{x : \tau \in \Gamma \\\\ \tau > \tau}{\Gamma , x : \tau \vdash x : \tau}
      }{\Gamma \vdash \lambda x . x : \tau \rightarrow \tau} \\
      \infer*[Right=App]{
        \infer*[Right=Var]{z : \tau \rightarrow \tau \in \Gamma \\\\ \tau \rightarrow \tau > \tau \rightarrow \tau}{\Gamma , z : \tau \rightarrow \tau \vdash z : \tau \rightarrow \tau} \\\\
        \infer*[Right=Var]{z : \tau \rightarrow \tau \in \Gamma \\\\ \tau \rightarrow \tau > \tau \rightarrow \tau}{\Gamma , z : \tau \rightarrow \tau
          \vdash z : \tau \rightarrow \tau}
      }{\Gamma , z : \tau \vdash z \ z : \tau \rightarrow \tau}
    }
    {\Gamma \vdash \letin{z = \lambda x . x}{z \ z} : \tau \rightarrow \tau}
  \end{mathpar}
  \tikz \graph[tree layout] {
    let/"$\letin{z = \lambda x . x}{z \ z}$";
    abs/"$\lambda x . x$";
    app/"$z \ z$";
    var0/"$x$"; var1/"$z$"; var2/"$z$";
    let -> {abs, app};
    abs -> var0;
    app -> {var1, var2};
  };
  \qquad
  \tikz \graph[tree layout] {
    let/"\textsc{let}";
    abs/"\textsc{abs}";
    app/"\textsc{app}";
    var0/"\textsc{var}"; var1/"\textsc{var}"; var2/"\textsc{var}";
    let -> {abs, app};
    abs -> var0;
    app -> {var1, var2};
  };
  \caption{How synatx directed typing rules mean that the proof tree
    is isomorphic to the syntax tree.} \label{fig:syntaxdirected}
\end{figure}

In our system however, the subsumption rule \textsc{sub} prevents
this. For every typing judgement of the form $\Gamma \vdash e : \IO_\rho \tau$, there
are two possible proofs that can be constructed for it: the proof
corresponding to the syntax of $e$, and \textsc{sub}. Furthermore,
because the subheap relation is reflexive, its possible to have an
infinite proof tree with repeated applications of \textsc{sub} as
shown in figure~\ref{fig:infinitesub}. When
working with proofs this did not turn out to be too big of an
issue, but it is undoubtedly a little bit unsatisfying to lose such a
nice property of the system.

\begin{figure}
  \centering
  \begin{mathpar}
    \mprset {sep=1em}
    \infer*[Left=Sub]{
      \infer*[Left=Sub]{
        \infer*[Left=Sub]{
          \vdots \\
          \textsf{File} \subtyp \textsf{File} \\ \textsf{ok} \ \textsf{File}
        }{\Gamma \vdash \use{\textsf{File}}{\square} : \IO_{\textsf{File}}\square} \\
        \textsf{File} \subtyp \textsf{File} \\ \textsf{ok} \ \textsf{File}
      }{\Gamma \vdash \use{\textsf{File}}{\square} : \IO_{\textsf{File}}\square} \\
      \textsf{File} \subtyp \textsf{File} \\ \textsf{ok} \ \textsf{File}
    }{\Gamma \vdash \use{\textsf{File}}{\square} : \IO_{\textsf{File}} \square}
  \end{mathpar}
  \tikz \graph[tree layout] {
    "$\use{\textsf{File}}{\square}$" -> "$\square$";
  };
  \qquad
  \tikz \graph[tree layout] {
    sub/"\textsc{sub}" ->[loop above] sub;
  };
  \caption{How an infinite chain of \textsc{sub} can be produced,
    leading nowhere.} \label{fig:infinitesub}

\end{figure}


\section{Modelling state within the
  monad}\label{section:modellingstate}
The modelling of the IO monad is extremely simplified, and does
nothing more than sequence computation. In fact, it doesn't model the
main purpose of the IO monad, which is to model effects by keeping
track of the \textit{state} of the world. To illustrate this point,
the reduction rule for concurrency is completely sequential.
\[ \infer{ }{v \curlyvee w \leadsto v \bind \lambda v . (w \bind \lambda w . \lift{v \times w})} \]
In a real world, this would be pointless. We want to be able to
compute these expressions concurrently, so $\bind$ alone won't cut it.
What we most likely want to ...

\section{If statements}

\section{Separation logic}
In Section~\ref{sec:separationologic} we looked at separation logic,
and now that we have defined our system we can look at some parallels
between them. Take the frame rule again, which allows additional
predicates to be inferred in a specification, under the condition that
the code does not use any of the variables in the predicate.
\[
  \infer{\{p\} \ \emph{code} \ \{q\}}
  {\{p * r\} \ \emph{code} \ \{ q * r \}} \
  \text{\parbox{2in}{where no variable
    occurring free in r is modified by \emph{code}}}
\]
Our well-formed heap judgement has a rule that allows heaps to be
merged, under the condition that they do not overlap:
\[
  \infer{\textsf{ok} \ \rho \\ \textsf{ok} \ \rho' \\ \rho\cap\rho'=\emptyset}
  {\textsf{ok} \ \rho\cup\rho'}
\]
This mirrors the idea of separation logic, that we only need to worry
about the variables relevant to our code, or in our terminology, the
resources relevant to our type. So our subsumption rule, \textsc{Sub}, that lets
heaps get promoted to a larger heap, ends up being our version of the
frame rule. And the concurrency rule from separation logic:
\[
  \infer{ {\color{gray} \{p_1\}} \ \emph{code}_1 \ {\color{gray} \{q_1\}}
    \\
    {\color{gray} \{p_2\}} \ \emph{code}_2 \ {\color{gray} \{q_2\}}}
  { {\color{gray} \{p_1 * p_2\}} \ \emph{code}_1 \ || \ \emph{code}_2 \
    {\color{gray} \{q_1 * q_2\}}}
\]
Ends up becoming our concurrency typing rule, \textsc{conc}. The
preconditions and postconditions are the heaps in the $\IO$ type, and the
separating conjunction $*$ is our union $\cup$.
\[
  \infer{
    \Gamma \vdash e_1 : \IO_{\rho_1} \tau_1 \\
    \Gamma \vdash e_2 : \IO_{\rho_2} \tau_2 \\
    \textsf{ok} \ \rho_1 \cup \rho_2}
  {\Gamma \vdash e_1 \curlyvee e_2 : \IO_{\rho_1 \cup \rho_2} \ \tau_1 \times \tau_2}
\]


\section{Heap polymorphism}
It would be convenient if we were able to have expressions like the
following well-typed:
\begin{align*}
\Gamma &= \centerdot , f : \square \rightarrow \IO_{\textsf{File}} \square, g : \square \rightarrow \IO_{\textsf{Net}} \square \\
\Gamma &\vdash \letin{x = \llbracket \square \rrbracket}{(x \bind f) \curlyvee (x \bind g)} : \IO_{\textsf{File} \cup
  \textsf{Net}} \square \times \square
\end{align*}
This is not possible in the current type system: $x$ needs to be both
$\IO_{\textsf{File}}$ and $\IO_{\textsf{Net}}$ simultaneously! This is
very much the same question that Hindley, Damas and Milner set out to
solve, except instead of polymorphic \textit{types} we want to have
polymorphic \textit{heaps}.
The basic idea for this would involve extending the definition of a
heap to allow for variable lookup:
\begin{grammar}
  <heap $\rho$> ::= $r$ | $\sigma \cup \sigma'$ | \textsf{World} | $\textbf{h}$
\end{grammar}
And then redefining substitutions to be pairs of a map from
type variables to types, and a map from heap variables to heaps.
$$ S : ( \alpha \mapsto \tau \times h \mapsto \rho ) $$
Then in the definition of substitution, whenever a mapping from a heap
variable to heap is encountered we would apply the substitution.
\begin{align*}
  (\IO_{\rho'} \tau)[h/\rho] &= \IO_{\rho'[h/\rho]} \tau \\
  r[h/\rho] &= r  && \textsf{Definining substitution on heaps now} \\
  (\rho_1 \cup \rho_2)[h/\rho] &= \rho_1[h/\rho] \cup \rho_2[h/\rho] \\
  \textsf{World}[h/\rho] &= \textsf{World} \\
  h'[h/\rho] &=
            \begin{cases}
              \rho & \mathsf{if} h' = h \\
              h' & \mathsf{otherwise}
            \end{cases}
\end{align*}

%%% Local Variables:
%%% TeX-master: "report"
%%% TeX-engine: luatex
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
